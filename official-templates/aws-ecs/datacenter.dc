# AWS ECS Fargate datacenter
# Deploys to ECS Fargate with RDS, ElastiCache, S3, SES, KMS, and OTel observability

variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "us-east-1"
}

variable "vpc_id" {
  description = "VPC ID for deployment"
  type        = string
}

variable "cluster_name" {
  description = "ECS cluster name"
  type        = string
}

variable "domain" {
  description = "Base domain for environments"
  type        = string
  default     = "app.example.com"
}

variable "hosted_zone_id" {
  description = "Route53 hosted zone ID"
  type        = string
}

variable "certificate_arn" {
  description = "ACM certificate ARN for TLS"
  type        = string
}

variable "ses_identity_arn" {
  description = "AWS SES verified identity ARN for sending email"
  type        = string
  default     = ""
}

variable "ses_smtp_username" {
  description = "AWS SES SMTP username (IAM access key)"
  type        = string
  default     = ""
}

variable "ses_smtp_password" {
  description = "AWS SES SMTP password (IAM secret key)"
  type        = string
  sensitive   = true
  default     = ""
}

# ECS Cluster (shared across environments)
module "ecs_cluster" {
  plugin = "opentofu"
  build  = "./modules/ecs-cluster"
  inputs = {
    name   = variable.cluster_name
    region = variable.aws_region
    vpc_id = variable.vpc_id
  }
}

# Application Load Balancer (shared)
module "alb" {
  plugin = "opentofu"
  build  = "./modules/alb"
  inputs = {
    name            = "${variable.cluster_name}-alb"
    vpc_id          = variable.vpc_id
    certificate_arn = variable.certificate_arn
  }
}

environment {
  # Target group per environment
  module "target_group" {
    plugin = "opentofu"
    build  = "./modules/alb-target-group"
    inputs = {
      name    = environment.name
      vpc_id  = variable.vpc_id
      alb_arn = module.alb.arn
    }
  }

  # CloudWatch log group
  module "log_group" {
    plugin = "opentofu"
    build  = "./modules/cloudwatch-logs"
    inputs = {
      name           = "/ecs/${variable.cluster_name}/${environment.name}"
      retention_days = 30
    }
  }

  # DNS records
  module "dns_records" {
    plugin = "opentofu"
    build  = "./modules/route53-records"
    inputs = {
      hosted_zone_id = variable.hosted_zone_id
      domain         = "${environment.name}.${variable.domain}"
      alb_dns_name   = module.alb.dns_name
      alb_zone_id    = module.alb.zone_id
    }
  }

  # Security group for environment
  module "security_group" {
    plugin = "opentofu"
    build  = "./modules/security-group"
    inputs = {
      name   = "${environment.name}-sg"
      vpc_id = variable.vpc_id
    }
  }

  # Resource hooks
  database {
    module "rds_database" {
      plugin = "opentofu"
      build  = "./modules/rds-database"
      inputs = {
        name              = "${environment.name}-${node.name}"
        type              = element(split(":", node.inputs.type), 0)
        engine_version    = try(element(split(":", node.inputs.type), 1), null)
        region            = variable.aws_region
        vpc_id            = variable.vpc_id
        instance_class    = "db.t3.micro"
        allocated_storage = 20
        security_group_id = module.security_group.id
      }
    }

    outputs = {
      host     = module.rds_database.endpoint
      port     = module.rds_database.port
      database = module.rds_database.database_name
      url      = module.rds_database.connection_url
    }
  }

  # Task hook - run one-time containers (e.g., database migrations)
  # Uses ECS Tasks (Fargate) for one-time execution
  task {
    module "run_task" {
      plugin = "opentofu"
      build  = "./modules/ecs-task"
      inputs = {
        name              = "${node.component}--${node.name}"
        cluster           = variable.cluster_name
        vpc_id            = variable.vpc_id
        security_group_id = module.security_group.id
        log_group         = module.log_group.name
        image             = node.inputs.image
        command           = node.inputs.command
        environment       = node.inputs.environment
        # Use Fargate SPOT for cost-effective one-time tasks
        capacity_provider = "FARGATE_SPOT"
        cpu               = "256"
        memory            = "512"
      }
    }

    outputs = {
      id     = module.run_task.task_arn
      status = module.run_task.status
    }
  }

  bucket {
    module "s3_bucket" {
      plugin = "opentofu"
      build  = "./modules/s3-bucket"
      inputs = {
        name       = "${environment.name}-${node.name}"
        region     = variable.aws_region
        versioning = node.inputs.versioning
        public     = node.inputs.public
      }
    }

    outputs = {
      endpoint        = "https://s3.${variable.aws_region}.amazonaws.com"
      bucket          = module.s3_bucket.bucket_name
      region          = variable.aws_region
      accessKeyId     = module.s3_bucket.access_key_id
      secretAccessKey = module.s3_bucket.secret_access_key
    }
  }

  # Encryption key hook - asymmetric (RSA/ECDSA)
  # Generates key pair and stores in AWS Secrets Manager
  encryptionKey {
    when = node.inputs.keyType == "rsa" || node.inputs.keyType == "ecdsa"

    module "asymmetric_key" {
      plugin = "opentofu"
      build  = "./modules/secrets-manager-keypair"
      inputs = {
        name     = "${environment.name}/${node.component}/${node.name}"
        key_type = node.inputs.keyType
        key_size = node.inputs.keySize
        region   = variable.aws_region
      }
    }

    outputs = {
      privateKey       = module.asymmetric_key.private_key
      publicKey        = module.asymmetric_key.public_key
      privateKeyBase64 = module.asymmetric_key.private_key_base64
      publicKeyBase64  = module.asymmetric_key.public_key_base64
    }
  }

  # Encryption key hook - symmetric
  # Uses AWS KMS for key management
  encryptionKey {
    when = node.inputs.keyType == "symmetric"

    module "symmetric_key" {
      plugin = "opentofu"
      build  = "./modules/kms-key"
      inputs = {
        name   = "${environment.name}-${node.component}-${node.name}"
        region = variable.aws_region
      }
    }

    outputs = {
      key       = module.symmetric_key.key_material
      keyBase64 = module.symmetric_key.key_material_base64
    }
  }

  # SMTP hook - AWS SES
  smtp {
    module "ses_smtp" {
      plugin = "opentofu"
      build  = "./modules/ses-smtp"
      inputs = {
        region       = variable.aws_region
        identity_arn = variable.ses_identity_arn
      }
    }

    outputs = {
      host     = "email-smtp.${variable.aws_region}.amazonaws.com"
      port     = 587
      username = variable.ses_smtp_username
      password = variable.ses_smtp_password
    }
  }

  # Deployment hook - container-based (image present)
  deployment {
    when = node.inputs.image != null

    module "ecs_service" {
      plugin = "opentofu"
      build  = "./modules/ecs-service"
      inputs = merge(node.inputs, {
        cluster           = variable.cluster_name
        vpc_id            = variable.vpc_id
        security_group_id = module.security_group.id
        log_group         = module.log_group.name
      })
    }

    outputs = {
      id = module.ecs_service.service_id
    }
  }

  # Deployment hook - VM-based (runtime present, no image)
  # Provisions EC2 instances for workloads using the runtime property
  deployment {
    when = node.inputs.runtime != null && node.inputs.image == null

    module "ec2_vm" {
      plugin = "opentofu"
      build  = "./modules/ec2-vm"
      inputs = merge(node.inputs, {
        name           = "${environment.name}-${node.component}-${node.name}"
        subnet_id      = module.security_group.subnet_id
        security_group = module.security_group.id
      })
    }

    outputs = {
      id = module.ec2_vm.instance_id
    }
  }

  function {
    module "lambda" {
      plugin = "opentofu"
      build  = "./modules/lambda-function"
      inputs = merge(node.inputs, {
        name              = "${environment.name}-${node.name}"
        vpc_id            = variable.vpc_id
        security_group_id = module.security_group.id
      })
    }

    outputs = {
      id       = module.lambda.function_arn
      endpoint = module.lambda.function_url
    }
  }

  service {
    module "service_discovery" {
      plugin = "opentofu"
      build  = "./modules/service-discovery"
      inputs = {
        name        = node.name
        namespace   = environment.name
        target      = node.inputs.target
        target_type = node.inputs.target_type
        port        = node.inputs.port
      }
    }

    outputs = {
      host = module.service_discovery.dns_name
      port = module.service_discovery.port
      url  = "http://${module.service_discovery.dns_name}:${module.service_discovery.port}"
    }
  }

  route {
    module "alb_listener_rule" {
      plugin = "opentofu"
      build  = "./modules/alb-listener-rule"
      inputs = merge(node.inputs, {
        alb_arn          = module.alb.arn
        target_group_arn = module.target_group.arn
        domain           = "${environment.name}.${variable.domain}"
      })
    }

    outputs = {
      url      = "https://${environment.name}.${variable.domain}"
      hosts    = ["${environment.name}.${variable.domain}"]
      protocol = "https"
      host     = "${environment.name}.${variable.domain}"
      port     = 443
    }
  }

  cronjob {
    module "eventbridge_task" {
      plugin = "opentofu"
      build  = "./modules/eventbridge-scheduled-task"
      inputs = merge(node.inputs, {
        name    = "${environment.name}-${node.name}"
        cluster = variable.cluster_name
      })
    }

    outputs = {
      id = module.eventbridge_task.rule_arn
    }
  }

  databaseUser {
    module "rds_user" {
      plugin = "opentofu"
      build  = "./modules/rds-user"
      inputs = {
        database = node.inputs.database
        username = node.inputs.username
      }
    }

    outputs = {
      username = module.rds_user.username
      password = module.rds_user.password
      url      = module.rds_user.connection_url
    }
  }

  secret {
    module "secrets_manager" {
      plugin = "opentofu"
      build  = "./modules/secrets-manager"
      inputs = {
        name = "${environment.name}/${node.name}"
        data = node.inputs.data
      }
    }

    outputs = {
      id = module.secrets_manager.secret_arn
    }
  }

  dockerBuild {
    module "ecr_build" {
      plugin = "opentofu"
      build  = "./modules/ecr-build"
      inputs = {
        context    = node.inputs.context
        dockerfile = node.inputs.dockerfile
        target     = node.inputs.target
        args       = node.inputs.args
        region     = variable.aws_region
      }
    }

    outputs = {
      image = module.ecr_build.image_uri
    }
  }

  # Observability hook - OTel collector sidecar on ECS with CloudWatch backend
  # Deploys an OpenTelemetry Collector as an ECS service that receives OTLP
  # telemetry and exports to CloudWatch Logs, CloudWatch Metrics, and X-Ray.
  observability {
    module "otel_collector" {
      plugin = "opentofu"
      build  = "./modules/ecs-otel-collector"
      inputs = {
        name              = "${environment.name}-otel-collector"
        cluster           = variable.cluster_name
        region            = variable.aws_region
        vpc_id            = variable.vpc_id
        security_group_id = module.security_group.id
        log_group         = module.log_group.name
      }
    }

    outputs = {
      endpoint       = module.otel_collector.otlp_endpoint
      protocol       = "http/protobuf"
      query_type     = "cloudwatch"
      query_endpoint = "https://logs.${variable.aws_region}.amazonaws.com"
      dashboard_url  = "https://${variable.aws_region}.console.aws.amazon.com/cloudwatch/home?region=${variable.aws_region}#dashboards"
      attributes = {
        "cloud.provider" = "aws"
        "cloud.region"   = variable.aws_region
        "cloud.platform" = "aws_ecs"
      }
    }
  }
}
